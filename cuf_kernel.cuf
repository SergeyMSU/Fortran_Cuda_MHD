module MY_CUDA
	use STORAGE
	use cudafor
	use Solvers
	implicit none

	integer(4), device :: dev_num_param
	real(8), constant :: dev_GM = 0.00439795_8
	real(8), constant :: dev_Omega = 2.0 * par_pi_8/6.47143
	real(8), constant :: dev_lambda = 0.52359878_8
	! rho vx vy vz p bx by bz

    real(8), device :: dev_time_all                       ! Текущее время расчёта
    INTEGER(4), device :: dev_N_cell                       ! Число ячеек в сетке
    INTEGER(4), device :: dev_N_gran                       ! Число граней в сетке

	real(8), device :: time_step
	real(8), device :: time_step2
	real(8), device :: rotate_velosity(3)


	real(8), device, allocatable :: dev_Cell_par(:, :)     ! (8, :)

	real(8), device, allocatable :: dev_Cell_center(:, :)      ! (3, :)
	real(8), device, allocatable :: dev_Cell_Volume(:)         ! (:)

	real(8), device, allocatable :: dev_Gran_normal(:,:)       ! (3, :) Нормаль грани   
    real(8), device, allocatable :: dev_Gran_square(:)         ! (:) Площадь грани
	real(8), device, allocatable :: dev_Gran_center(:,:)			! (3, :)

	integer(4), device, allocatable :: dev_Cell_gran(:,:)            ! (6, :) Набор из 6 граней для каждой ячейки (если номер = 0, то грани нет в этом направлении)
	real(8), device, allocatable :: dev_Cell_dist(:)                 ! Минимальное расстояние до грани в каждой ячейки 

	integer(4), device, allocatable :: dev_Gran_neighbour(:,:) ! Соседи каждой грани (2,:) имеют по 2 соседа, нормаль ведёт от первого ко второму
	integer(4), device, allocatable :: dev_Gran_neighbour_TVD(:,:) ! TVD-Соседи каждой грани (2,:) имеют по 2 соседа

	integer(4), device, allocatable :: dev_Gran_type(:)                 ! Показывает тип грани

	real(8), device, allocatable :: dev_Gran_POTOK(:, :)       ! (10, :) поток грани    последний - дивергенция магнитного поля для очистки


    contains 

	!@cuf attributes(host, device) & 
    subroutine spherical_skorost(z, x, y, Vz, Vx, Vy, Vr, Vphi, Vtheta)
        ! Variables
        use My_func
        implicit none
        real(8), intent(in) :: x, y, z, Vx, Vy, Vz
        real(8), intent(out) :: Vr, Vphi, Vtheta
        real(8) :: r_1, the_1, phi_1

        r_1 = sqrt(x * x + y * y + z * z)
        the_1 = acos(z / r_1)
        phi_1 = polar_angle(x, y)

        Vr = Vx * sin(the_1) * cos(phi_1) + Vy * sin(the_1) * sin(phi_1) + Vz * cos(the_1);
        Vtheta = Vx * cos(the_1) * cos(phi_1) + Vy * cos(the_1) * sin(phi_1) - Vz * sin(the_1);
        Vphi = -Vx * sin(phi_1) + Vy * cos(phi_1);
	end subroutine spherical_skorost

	!@cuf attributes(host, device) & 
    subroutine dekard_skorost(z, x, y, Vr, Vphi, Vtheta, Vz, Vx, Vy)
        use My_func
        implicit none
        real(8), intent(in) :: x, y, z,  Vr, Vphi, Vtheta
        real(8), intent(out) :: Vx, Vy, Vz
        real(8) :: r_2, the_2, phi_2

        r_2 = sqrt(x * x + y * y + z * z);
        the_2 = acos(z / r_2);
        phi_2 = polar_angle(x, y);
        
        !print*, r_2, the_2, phi_2, Vr, Vphi, Vtheta
        !print*, sin(the_2), cos(phi_2), cos(the_2), sin(phi_2)

        Vx = Vr * sin(the_2) * cos(phi_2) + Vtheta * cos(the_2) * cos(phi_2) - Vphi * sin(phi_2);
        Vy = Vr * sin(the_2) * sin(phi_2) + Vtheta * cos(the_2) * sin(phi_2) + Vphi * cos(phi_2);
        Vz = Vr * cos(the_2) - Vtheta * sin(the_2);
	end subroutine dekard_skorost

	function matvec_mult(A, v) result(w)
		real(8), intent(in) :: A(3,3), v(3)
		real(8) :: w(3)
		integer :: i, j
		
		do i = 1, 3
			w(i) = 0.0d0
			do j = 1, 3
				w(i) = w(i) + A(i,j) * v(j)
			end do
		end do
	end function matvec_mult


		! Матрица поворота вокруг оси Z
	function rotationMatrixZ(angle_rad) result(R)
		real(8), intent(in) :: angle_rad
		real(8) :: R(3,3)
		real(8) :: cos_angle, sin_angle
		
		cos_angle = cos(angle_rad)
		sin_angle = sin(angle_rad)
		
		R = reshape([ cos_angle,  sin_angle, 0.0d0, &
					 -sin_angle,  cos_angle, 0.0d0, &
					0.0d0,      0.0d0,    1.0d0 ], [3, 3])
	end function rotationMatrixZ

	! Матрица поворота вокруг оси X
	function rotationMatrixX(angle_rad) result(R)
		real(8), intent(in) :: angle_rad
		real(8) :: R(3,3)
		real(8) :: cos_angle, sin_angle
		
		cos_angle = cos(angle_rad)
		sin_angle = sin(angle_rad)
		
		R = reshape([ 1.0d0,     0.0d0,     0.0d0, &
					0.0d0,     cos_angle, sin_angle, &
					0.0d0,     -sin_angle, cos_angle ], [3, 3])
	end function rotationMatrixX

	attributes(device) real(8) function dev_norm2(x)
		! РАБОТАЕТ ТОЛЬКО ДЛЯ ТРЁХМЕРНЫХ ВЕКТОРОВ
		implicit none
		real(8), device :: x(*)

		dev_norm2 = sqrt(x(1)**2 + x(2)**2 + x(3)**2)
		return
	end function dev_norm2

	attributes(device) function cross_product(a, b) result(c)
		real(8), dimension(3), intent(in) :: a, b
		real(8), dimension(3) :: c
		
		c(1) = a(2)*b(3) - a(3)*b(2)
		c(2) = a(3)*b(1) - a(1)*b(3) 
		c(3) = a(1)*b(2) - a(2)*b(1)
	end function cross_product

    subroutine CUDA_info()
	    ! Функция, печатающая информацию о видеокарте на экран (только о первой видеокарте)
	    use OMP_lib
         use cudafor
        
        implicit none
        
         type (cudaDeviceProp) :: prop
        integer :: nDevices = 0, i, ierr
        
         ierr = cudaGetDeviceCount(nDevices)
		
		 print*, "  "
		 print*, "  "
		print*, "CUDA_info()"
		print*, "  "
        
        write(*, "('Chislo videokard: ', i0)")  nDevices
		
		if (nDevices == 0) then
			STOP "NET CUDA!!!"
		end if
		
		 ierr = cudaGetDeviceProperties(prop, 0)
		
		 write(*, "('Version: ', i0,'.',i0)") prop%major, prop%minor
		 write(*, "('Chislo mulitiprocessorov: ', i0)") prop%multiProcessorCount
		 write(*, "('Max chislo potokov/multiprocessor: ', i0)") prop%maxThreadsPerMultiprocessor
		 write(*, "('Global memory (GB): ', f9.3)") prop%totalGlobalMem / 1024.0**3
		
		 print*, "Konfiguration of working"
		 write(*, "('max grid size: ', 2(i0, ' x '), i0 )") prop%maxGridSize
		 write(*, "('max block size: ', 2(i0, ' x '), i0 )") prop%maxThreadsDim
		 write(*, "('Max chislo potokov v blocke: ', i0)") prop%maxThreadsPerBlock
		print*, "                "
		print*, "                "
	end subroutine CUDA_info

	subroutine Set_CUDA()
		! Здесь просто выделяется память на девайсе и скачиваются все массивы из хоста на девайс

		dev_num_param = host_num_param

		dev_time_all = host_time_all
		dev_N_cell = host_N_cell
		dev_N_gran = host_N_gran

		allocate(dev_Cell_par, mold = host_Cell_par)
		allocate(dev_Cell_center, mold = host_Cell_center)
		allocate(dev_Cell_Volume, mold = host_Cell_Volume)
		allocate(dev_Cell_gran, mold = host_Cell_gran)
		dev_Cell_par = host_Cell_par
		dev_Cell_center = host_Cell_center
		dev_Cell_Volume = host_Cell_Volume
		dev_Cell_gran = host_Cell_gran

		allocate(dev_Gran_normal, mold = host_Gran_normal)
		allocate(dev_Gran_square, mold = host_Gran_square)
		allocate(dev_Gran_center, mold = host_Gran_center)
		allocate(dev_Gran_neighbour, mold = host_Gran_neighbour)
		allocate(dev_Gran_neighbour_TVD, mold = host_Gran_neighbour_TVD)
		allocate(dev_Gran_type, mold = host_Gran_type)
		allocate(dev_Gran_POTOK, mold = host_Gran_POTOK)
		dev_Gran_normal = host_Gran_normal
		dev_Gran_square = host_Gran_square
		dev_Gran_center = host_Gran_center
		dev_Gran_neighbour = host_Gran_neighbour
		dev_Gran_neighbour_TVD = host_Gran_neighbour_TVD
		dev_Gran_type = host_Gran_type
		dev_Gran_POTOK = host_Gran_POTOK
	end subroutine Set_CUDA

	subroutine CUDA_START_MGD()
		integer :: step, now, now2, step2
		type(dim3) :: grid, tBlock
		integer(4):: ierrSync, ierrAsync, nx, ny, ijk, istat, potok_in_block, all_step
		real(8) :: local1, rotate_velosity_local(3), alpha
		real(8) :: point(3), dev_Omega_local
		type(cudaEvent) :: startEvent, stopEvent
		integer(4), device :: dev_now, dev_now2
		real :: time_work
		real(8) :: R_x(3,3), R_z(3,3), temp_vec(3)
		real(8) :: lambda

		lambda = dev_lambda
		dev_Omega_local = dev_Omega

		call Set_CUDA()

		potok_in_block = 256
		tBlock = dim3(32, 8, 1)
		
		now = 2
		time_step2 = 0.00002_8              ! Шаг по времени (хранится на девайсе)
		
		istat = cudaEventCreate(startEvent)
		istat = cudaEventCreate(stopEvent)
		istat = cudaEventRecord(startEvent, 0)

		point = (/0.0, 0.0, dev_Omega_local/);
		R_x = rotationMatrixX(lambda)

		all_step = 10

		do step = 1,  all_step  ! ---------------------------------------------------------------------------------------------------
			ierrAsync = cudaDeviceSynchronize()
			if (mod(step, 1) == 0) then
				local1 = time_step2
				print*, "Step = ", step , "  step_time = ", local1, " all step = ", all_step
			end if


			time_step = time_step2
			time_step2 = 100000000.0_8
			
			local1 = dev_time_all
			local1 = local1 + time_step
			dev_time_all = local1

			print*, "all time = ", local1

			alpha = local1 * dev_Omega_local;
			

			R_z = rotationMatrixZ(alpha)
			
			! Последовательное умножение: R_x * (R_z * point)
			temp_vec = matvec_mult(R_z, point)      
			rotate_velosity_local = matvec_mult(R_x, temp_vec) 
			rotate_velosity = rotate_velosity_local

			print*, "rotate_velosity_local = ", rotate_velosity_local(1), rotate_velosity_local(2), rotate_velosity_local(3)
			
			now2 = now
			now = mod(now, 2) + 1
			ierrAsync = cudaDeviceSynchronize()
			dev_now = now
			dev_now2 = now2
			ierrAsync = cudaDeviceSynchronize()


			!call CUF_MGD_grans <<< dim3(1,1,1), dim3(1,1,1)>>> (dev_now)  ! цикл по граням
			call CUF_MGD_grans <<< ceiling(real(dev_N_gran)/potok_in_block), potok_in_block>>> (dev_now)  ! цикл по граням
			
			ierrSync = cudaGetLastError(); 
			ierrAsync = cudaDeviceSynchronize(); 
			if (ierrSync /= cudaSuccess) write (*,*) 'Error Sinc start 16: ', cudaGetErrorString(ierrSync); 
			if(ierrAsync /= cudaSuccess) write(*,*) 'Error ASync start 17: ', cudaGetErrorString(cudaGetLastError())


			call CUF_MGD_cells <<< ceiling(real(dev_N_cell)/potok_in_block), potok_in_block>>> (dev_now)  ! цикл по ячейкам
			
			ierrSync = cudaGetLastError(); 
			ierrAsync = cudaDeviceSynchronize(); 
			if (ierrSync /= cudaSuccess) write (*,*) 'Error Sinc start 18: ', cudaGetErrorString(ierrSync); 
			if(ierrAsync /= cudaSuccess) write(*,*) 'Error ASync start 19: ', cudaGetErrorString(cudaGetLastError())
	
		end do
		

		istat = cudaEventRecord(stopEvent, 0)
		istat = cudaEventSynchronize(stopEvent)
		istat = cudaEventElapsedTime(time_work, startEvent, stopEvent)
		print *, "CUDA Time work: ", (time_work)/(60*1000.0), "   in minutes"

	end subroutine CUDA_START_MGD

end module MY_CUDA